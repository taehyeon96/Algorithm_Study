'''
# 카카오 2018 공채 코테 1번 : 비밀지도
* 링크 : https://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/
* 난이도 : 하

### 메모

비밀지도는 숫자로 암호화 되어있음
위치를 확인하기 위해 암호를 해독해야함

n * n
1. 각 칸은 공백("")과 벽("#") 두 종류로 이루어짐
2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있음
  - 지도1, 2 둘 중 하나라도 벽(OR) -> 전체 지도의 해당 위치는 무조건 벽
  - 지도1, 2 둘 다 공백(AND) -> 전체 지도의 해당 위치는 공백
3. 지도1과 2는 정수배열로 암호화됨
4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열
---

### 입출력 설명
arr1	[9, 20, 28, 18, 11]
arr2	[30, 1, 21, 17, 28]

출력	["#####","# # #", "### #", "# ##", "#####"]

* 즉, 9와 30을 "#####"로 만들라는거임
* 20과 1은 "# # #" 로 만들라는거고

>예를들어
>>숫자 9  ->  1001
>>숫자 30 -> 11110 을 합쳐주겠다 (or연산하겟다)
=> bin(9|30) => ob11111 출력됨
=> bin(9|30)[2:] => 11111
=> bin(9|30)[2:].replace('1', "#").replace('0', " ") => 11111
=> bin(20|1)[2:].replace('1', "#").replace('0', " ") => # # #

* replace 중첨 가능함 중요!

---
### 주의사항
* 3과 5일 경우
11
101 인데
=> | 연산 수행하면 11100 이렇게 되버림

따라서
_11
101 이렇게 연산을 수행해줘야함 (중요)

* **zfill() 함수!!!**
  - 문자열에서 자릿수를 맞춰주는 함수!! (파라미터에 자릿수)
  - bin(3|5)[2:].zfill(5) 를 실행하면
    - 00111 결과로 나옴
'''

n = int(input())
arr1 = list(map(int, input().split()))
arr2 = list(map(int, input().split()))

# 1) 일반 방법
def sol1():
    ans = []
    for i in range(n):
        ans.append(bin(arr1[i]|arr2[i])[2:].zfill(n).replace('1', '#').replace('0',' '))
    return ans

# 2) packing (zip함수)를 사용한 방법
def sol2():
    ans = []
    for i, j in zip(arr1, arr2):
        ans.append(bin(i|j)[2:].zfill(n).replace("1", "#").replace("0", " "))
    return ans

print(sol1())
print(sol2())
